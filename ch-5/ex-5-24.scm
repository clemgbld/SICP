'(
eval-dispatch
  (test (op self-evaluating?) (reg exp))
  (branch (label ev-self-eval))
  (test (op variable?) (reg exp))
  (branch (label ev-variable))
  (test (op quoted?) (reg exp))
  (branch (label ev-quoted))
  (test (op assignment?) (reg exp))
  (branch (label ev-assignment))
  (test (op definition?) (reg exp))
  (branch (label ev-definition))
  (test (op if?) (reg exp))
  (branch (label ev-if))
  (test (op lambda?) (reg exp))
  (branch (label ev-lambda))
  (test (op begin?) (reg exp))
  (branch (label ev-begin))
  ;cond dispatch added here
  (test (op cond?) (reg exp))
  (branch (label ev-cond) )
  ;--
  (test (op application?) (reg exp))
  (branch (label ev-application))
  (goto (label unknown-expression-type))
  ev-cond
  (assign exp (op cond-clauses) (reg exp)) 
  (goto (label cond-loop ))
  cond-loop
  (assign unenv (op car) (reg exp))
  (test (op cond-else-clause?) (reg unenv))
  (branch (label ev-cond-else))
  (save exp) 
  (save env)
  (save continue)
  (assign continue (label ev-cond-decide))
  (assign exp (op cond-predicate) (reg unenv) )
  (goto (label eval-dispatch))
  ev-cond-else
  (assign exp (cdr) (reg exp))
  (test (null?) (reg exp))
  (branch (label ev-cond-else-valid))
  (assign val (const "ELSE clause isn't last: COND->IF") )
  ev-cond-else-valid
  (assign exp (op cond-actions) (reg unenv))
  (goto (label eval-dispatch ))
  ev-cond-decide
  (restore continue)
  (restore env)
  (restore exp)
  (test (op true?) (reg val))
  (branch (label ev-cond-consequent))
  (assign exp (cdr) (reg exp))
  (test (op null?) (reg exp))
  (branch (reg continue))
  (goto (label cond-loop))
  ev-cond-consequent
  (assign exp (car) (reg exp))
  (assign exp (cond-actions) (reg exp))
  (goto (label eval-dispatch))
 )
